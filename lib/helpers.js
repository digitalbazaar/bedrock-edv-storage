/*!
 * Copyright (c) 2018-2019 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

const base58 = require('bs58');
const bedrock = require('bedrock');
const brZCapStorage = require('bedrock-zcap-storage');
const {config, util: {BedrockError}} = bedrock;
const {promisify} = require('util');
const crypto = require('crypto');
const getRandomBytes = promisify(crypto.randomBytes);
const jsigs = require('jsonld-signatures');
const {SECURITY_CONTEXT_V2_URL} = jsigs;
const {Ed25519Signature2018} = jsigs.suites;
// const {CapabilityDelegation} = require('ocapld');
// const {ensureAuthenticated} = brPassport;
const storage = require('./storage');
const {verifyCapabilityInvocation} = require('http-signature-zcap-verify');

const routes = {
  edvs: '/edvs',
};

const {baseUri} = config.server;
const baseStorageUrl = `${baseUri}${routes.edvs}/`;

// TODO: some of the following code is a target for reusability in other
// modules and should be factored out for reuse

// Note: for dereferencing `did:key` URLs
exports.DOCUMENT_LOADER = async url => {
  // TODO: move to did-key lib
  if(url.startsWith('did:key:')) {
    const publicKeyBase58 = _parsePublicKeyBase58(url);
    return {
      contextUrl: null,
      documentUrl: url,
      document: {
        '@context': SECURITY_CONTEXT_V2_URL,
        id: url,
        publicKey: [{
          id: url,
          // TODO: determine from parsing multibase key
          type: 'Ed25519VerificationKey2018',
          controller: url,
          publicKeyBase58
        }],
        authentication: [url],
        assertionMethod: [url],
        capabilityDelegation: [url],
        capabilityInvocation: [url]
      }
    };
  }
  const error = new Error(`Dereferencing url "${url}" is prohibited.`);
  error.name = 'NotAllowedError';
  error.httpStatusCode = 400;
  throw error;
};

// TODO: move into JSON schema validator
exports.assert128BitId = id => {
  try {
    // verify ID is multibase base58-encoded 16 bytes
    const buf = base58.decode(id.substr(1));
    // multibase base58 (starts with 'z')
    // 128-bit random number, multibase encoded
    // 0x00 = identity tag, 0x10 = length (16 bytes) + 16 random bytes
    if(!(id.startsWith('z') &&
      buf.length === 18 && buf[0] === 0x00 && buf[1] === 0x10)) {
      throw new Error('Invalid identifier.');
    }
  } catch(e) {
    throw new BedrockError(
      `Identifier "${id}" must be multibase, base58-encoded ` +
      'array of 16 random bytes.',
      'SyntaxError',
      {public: true, httpStatusCode: 400});
  }
};

exports.authorize = async ({
  req, expectedTarget, expectedRootCapability, expectedAction
}) => {
  // wrap document loader to always generate root zcap from config
  // description in storage
  const wrappedDocumentLoader = async url => {
    if(url.startsWith('did:key:')) {
      return exports.DOCUMENT_LOADER(url);
    }

    // dynamically generate zcap for root capability if applicable
    const zcap = await exports.generateRootCapability(url);
    if(zcap) {
      return {
        contextUrl: null,
        documentUrl: url,
        document: zcap
      };
    }

    // see if zcap is in storage
    try {
      const {authorization} = await brZCapStorage.authorizations.get(
        {id: url, invocationTarget: expectedTarget});
      return {
        contextUrl: null,
        documentUrl: url,
        document: authorization.capability
      };
    } catch(e) {
      if(e.name !== 'NotFoundError') {
        throw e;
      }
    }

    return exports.DOCUMENT_LOADER(url);
  };

  const url = `${config.server.baseUri}${req.originalUrl}`;
  const {method, headers} = req;
  const result = await verifyCapabilityInvocation({
    url, method, headers,
    getInvokedCapability: exports.getInvokedCapability,
    documentLoader: wrappedDocumentLoader,
    expectedHost: config.server.host,
    expectedTarget, expectedRootCapability, expectedAction,
    // TODO: support RsaSignature2018 and other suites?
    suite: [new Ed25519Signature2018()]
  });
  if(!result.verified) {
    throw new BedrockError(
      'Permission denied.', 'NotAllowedError', {
        httpStatusCode: 400,
        public: true
      }, result.error);
  }
  return {
    valid: result.verified,
    ...result
  };
};

exports.getInvokedCapability = async ({id, expectedTarget}) => {
  // if the capability is a root zcap generated by this server then its
  // `id` will map to an invocation target; if so, dynamically generate the
  // zcap as it is the root authority which is automatically authorized
  const zcap = await exports.generateRootCapability(id);
  if(zcap) {
    return zcap;
  }

  // must get capability from authorizations storage
  try {
    const {authorization} = await brZCapStorage.authorizations.get({
      id,
      invocationTarget: expectedTarget
    });
    return authorization.capability;
  } catch(e) {
    if(e.name === 'NotFoundError') {
      throw new BedrockError(
        'Permission denied.', 'NotAllowedError', {
          httpStatusCode: 400,
          public: true
        }, e);
    }
    throw e;
  }
};

exports.getInvocationTarget = url => {
  // look for `/edvs/<edvId>/zcaps/`
  let idx = url.indexOf(baseStorageUrl);
  if(idx !== 0) {
    return null;
  }

  // skip EDV ID
  const edvIdIdx = baseStorageUrl.length;
  idx = url.indexOf('/', edvIdIdx);
  if(idx === -1) {
    return null;
  }
  const edvId = `${baseStorageUrl}${url.substring(edvIdIdx, idx)}`;

  // skip `zcaps`
  idx = url.indexOf('zcaps/', idx + 1);
  if(idx === -1) {
    return null;
  }

  // valid root zcap invocation targets:
  // `/edvs/<edvId>/documents`
  // `/edvs/<edvId>/query`
  // `/edvs/<edvId>/authorizations`
  // root `/edvs/<edvId>/documents/...`
  const path = url.substr(idx + 6 /* 'zcaps/'.length */);
  if(!(['documents', 'query', 'authorizations'].includes(path) ||
    (path.startsWith('documents/') && path.length > 10))) {
    return null;
  }

  // return invocation target for the given root zcap URL
  return {
    target: `${edvId}/${path}`,
    edvId
  };
};

exports.generateRootCapability = async url => {
  const result = exports.getInvocationTarget(url);
  if(!result) {
    return null;
  }
  const {target, edvId} = result;

  // dynamically generate zcap for root capability
  const {config} = await storage.getConfig({actor: null, id: edvId});
  return {
    '@context': SECURITY_CONTEXT_V2_URL,
    id: url,
    invocationTarget: target,
    controller: config.controller,
    invoker: config.invoker,
    delegator: config.delegator
  };
};

function _parsePublicKeyBase58(didKeyUrl) {
  const fingerprint = didKeyUrl.substr('did:key:'.length);
  // skip leading `z` that indicates base58 encoding
  const buffer = base58.decode(fingerprint.substr(1));
  // assume buffer is: 0xed 0x01 <public key bytes>
  return base58.encode(buffer.slice(2));
}

exports.generateRandom = async () => {
  // 128-bit random number, multibase encoded
  // 0x00 = identity tag, 0x10 = length (16 bytes)
  const buf = Buffer.concat([
    Buffer.from([0x00, 0x10]),
    await getRandomBytes(16)
  ]);
  // multibase encoding for base58 starts with 'z'
  return 'z' + base58.encode(buf);
};
